# 初始化列表(Initializer Lists)
+ 声明变量时，初始值不确<br>
`int i; // i has undefined value`<br>
`int *p; // p has undefined value`<br>
+ 初始化列表声明，默认为1<br>
`int j{}; // j has initialized by 0`<br>
`int *q{}; // q is initialized by nullptr`<br>
`value_type _M_instance[_Nm ? _Nm : 1];`
+ 复制初始化列表，浅拷贝<br>
+ 初始化列表改变标准库<br>
`cout << max({54, 16, 48, 8}); // 54`<br>
# explicit关键字
+ none explicit one argument constructor可以进行隐式转换<br>
+ 添加explicit之后，拒绝隐式转换
# 范围for
```
for(const auto &elem : coll) {
    cout << elem << endl;
}

for(auto _pow = coll.begin(), _pos != coll.end(); ++_pos) {
    const auto &elem = *_pos;
    cout << elem << endl;
}
```
# =default, =delete, =0
+ 没有默认构造函数会报错
+ =0只能用于virtual函数
# 别名(模板别名) Alias Template(template typedef)
+ typename向编译器提供未知标识符是类型的提示
```
template <typename T>
using Vec = std::vector<T, MyAlloc<T>>;

// they are same
Vec<int> coll;
std::vector<int, MyAlloc<int>> coll;

// 使用marco无法达到相同效果
// 下面的宏定义报错
#define Vec<T> template<typename T> std::vector<T, MyAlloc<T>>
-->
Vec<int> coll;
template<typename int> std::vector<int, MyAlloc<int>>; // 不是想要的

// 使用typedef亦无法达到相同效果，因为typedef不接受参数
// 写成如下也不是我们想要的
typedef std::vector<int, MyAlloc<int>> Vec

template<typename Container>
void test_moveable(Container c)
{
    typedef typename iterator_traits<typename Container::iterator>::value_type Valtype;
    for(int i = 0; i < SIZE; i++) {
        c.insert(c.end(), Valtype());
    }
}
```
# template template parameter + alias template
```
template<typename T, template<class> class Container>
class XCLs {
private:
    Container<T> c;
public:
    XCLs() {
        for(long i = 0; i < SIZE; i++) {
            c.insert(c.end(), T());
        }
        out_port_static_data(T());
        Container<T> cl(c);
        Container<T> c2(std::move(c));
        c1.swap(c2);
    }
}

// 该行报错
// XCLs<MyString, vector> c1;

// 不能在function body内声明
template<typename T>
using Vec = vector<T, allocator<T>>;

template<typename T>
using Lst = list<T, allocator<T>>;

template<typename T>
using Deq = deque<T, allocator<T>>;

XCLs<Mystring, Vec> c1;
XCLs<MyStrNoMove, Vec> c2;
```

# 类型别名 Type Alias
+ 函数名称是函数指针，函数地址
```
// type alias, idential to
// typedef void (*func)(int, int);
using func = void (*)(int, int);

// the name 'func' now denotes a pointer to function
void example(int, int) {}
func fn = example;
```

```
// type alias can introduce a member typedef name
template<typename T>
struct Container {
    using value_type = T;
    // same as typedef T value_type;
};

// which can be used in generic programming
template<typename Cntr>
void fn2(const Cntr &c) {
    typename Cntr::value_type n;
}

// type alias used to hide a template parameter
template<class ChartT> using mystyring = 
    std::basic_string<CharT, std::char_traits<CharT>>;

mystring<char> str;
```
<string>和<string_fwd.h>都有以下typedef:
`typedef basic_string<char> string;`

# using
+ using-directives for namespace
`using namespace std;`
+ using-declarations for namespace members
`using std::cout;`
+ using-declarations for class members
`using _Base::_M_allocate;`
+ type alias
`using func = void (*)(int, int);`
+ alias template declaration
```
template<class CharT> using mystring =
    std::basic_string<CharT, std::char_traits<CharT>>;
```
# noexcept
```
void foo() noexpect;
void func() noexpect(true);
std::terminate();
std::abort();
```
If the constructor is not noexpect, std::vector can't use it.

# override
```
struct Base {
    virtual void vfunc(float) {}
};
struct Derived1:Base {
    virtual void vfunc(int) {}
    // accidentally create a new virtual function, when one intended to override a base class function.
    // This is a common problem, particularly when a user goes to modify the base class.
}

struct Derived2:Base {
    virtual void vfunc(int) override {}
    // [Error] 'virtual void Derived2::vfunc(int)' marked override, but does not override

    // override means that the compiler will check the base class(es) to see if there is
    // a virtual function with this exact signature
    // And if there is not, the compiler will indicate an error.

    virtual void vfunc(float) override {}
};
```

# final
```
struct Base1 final {}
struct Derived1:Base1 {}
// [Error] can't derive from 'final' base 'Base1' in derived type 'Derived1'

struct Base2 {
    virtual void() final;
};

struct Derived2:Base2 {
    void f();
    // [Error] overriding final function 'virtual void Base2::f()'
};