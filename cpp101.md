# 初始化列表(Initializer Lists)
+ 声明变量时，初始值不确<br>
`int i; // i has undefined value`<br>
`int *p; // p has undefined value`<br>
+ 初始化列表声明，默认为1<br>
`int j{}; // j has initialized by 0`<br>
`int *q{}; // q is initialized by nullptr`<br>
`value_type _M_instance[_Nm ? _Nm : 1];`
+ 复制初始化列表，浅拷贝<br>
+ 初始化列表改变标准库<br>
`cout << max({54, 16, 48, 8}); // 54`<br>
# explicit关键字
+ none explicit one argument constructor可以进行隐式转换<br>
+ 添加explicit之后，拒绝隐式转换
# 范围for
```
for(const auto &elem : coll) {
    cout << elem << endl;
}

for(auto _pow = coll.begin(), _pos != coll.end(); ++_pos) {
    const auto &elem = *_pos;
    cout << elem << endl;
}
```
# =default, =delete, =0
+ 没有默认构造函数会报错
+ =0只能用于virtual函数
# 别名(模板别名) Alias Template(template typedef)
+ typename向编译器提供未知标识符是类型的提示
```
template <typename T>
using Vec = std::vector<T, MyAlloc<T>>;

// they are same
Vec<int> coll;
std::vector<int, MyAlloc<int>> coll;

// 使用marco无法达到相同效果
// 下面的宏定义报错
#define Vec<T> template<typename T> std::vector<T, MyAlloc<T>>
-->
Vec<int> coll;
template<typename int> std::vector<int, MyAlloc<int>>; // 不是想要的

// 使用typedef亦无法达到相同效果，因为typedef不接受参数
// 写成如下也不是我们想要的
typedef std::vector<int, MyAlloc<int>> Vec

template<typename Container>
void test_moveable(Container c)
{
    typedef typename iterator_traits<typename Container::iterator>::value_type Valtype;
    for(int i = 0; i < SIZE; i++) {
        c.insert(c.end(), Valtype());
    }
}
```
# template template parameter + alias template
```
template<typename T, template<class> class Container>
class XCLs {
private:
    Container<T> c;
public:
    XCLs() {
        for(long i = 0; i < SIZE; i++) {
            c.insert(c.end(), T());
        }
        out_port_static_data(T());
        Container<T> cl(c);
        Container<T> c2(std::move(c));
        c1.swap(c2);
    }
}

// 该行报错
// XCLs<MyString, vector> c1;

// 不能在function body内声明
template<typename T>
using Vec = vector<T, allocator<T>>;

template<typename T>
using Lst = list<T, allocator<T>>;

template<typename T>
using Deq = deque<T, allocator<T>>;

XCLs<Mystring, Vec> c1;
XCLs<MyStrNoMove, Vec> c2;
```

# 类型别名 Type Alias
+ 函数名称是函数指针，函数地址
```
// type alias, idential to
// typedef void (*func)(int, int);
using func = void (*)(int, int);

// the name 'func' now denotes a pointer to function
void example(int, int) {}
func fn = example;
```

```
// type alias can introduce a member typedef name
template<typename T>
struct Container {
    using value_type = T;
    // same as typedef T value_type;
};

// which can be used in generic programming
template<typename Cntr>
void fn2(const Cntr &c) {
    typename Cntr::value_type n;
}

// type alias used to hide a template parameter
template<class ChartT> using mystyring = 
    std::basic_string<CharT, std::char_traits<CharT>>;

mystring<char> str;
```
<string>和<string_fwd.h>都有以下typedef:
`typedef basic_string<char> string;`

# using
+ using-directives for namespace
`using namespace std;`
+ using-declarations for namespace members
`using std::cout;`
+ using-declarations for class members
`using _Base::_M_allocate;`
+ type alias
`using func = void (*)(int, int);`
+ alias template declaration
```
template<class CharT> using mystring =
    std::basic_string<CharT, std::char_traits<CharT>>;
```
# noexcept
```
void foo() noexpect;
void func() noexpect(true);
std::terminate();
std::abort();
```
If the constructor is not noexpect, std::vector can't use it.

# override
```
struct Base {
    virtual void vfunc(float) {}
};
struct Derived1:Base {
    virtual void vfunc(int) {}
    // accidentally create a new virtual function, when one intended to override a base class function.
    // This is a common problem, particularly when a user goes to modify the base class.
}

struct Derived2:Base {
    virtual void vfunc(int) override {}
    // [Error] 'virtual void Derived2::vfunc(int)' marked override, but does not override

    // override means that the compiler will check the base class(es) to see if there is
    // a virtual function with this exact signature
    // And if there is not, the compiler will indicate an error.

    virtual void vfunc(float) override {}
};
```

# final
```
struct Base1 final {}
struct Derived1:Base1 {}
// [Error] can't derive from 'final' base 'Base1' in derived type 'Derived1'

struct Base2 {
    virtual void() final;
};

struct Derived2:Base2 {
    void f();
    // [Error] overriding final function 'virtual void Base2::f()'
};
```
# decltype
+ used to declare return types
```
template<typename T1, typename T2>
auto add(T1 x, T2 y) -> decltype(x+y);
```
+ metaprogramming
```
typedef typename decltype(obj)::iterator iType;
// 等价于
typedef typename T::iterator iType;
```
+ used to pass the type of a lambda<br>
```
auto cmp = [](const Person& p1, const Person& p2) {return p1.lastname()<p2.lastname() || (p1.lastname()==p2.lastname() && p1.firstname()<p2.firstname())}
...
std::set<Person, decltype(cmp)> coll(cmp);
```

# Lambda
`[] {std::cout << "hello lambda" << std::endl;}`
```
// 直接调用lambda
// 打印hello lambda
[] {std::cout << "hello lambda" << std::endl;} ()

// 将lambda传递给一个变量，多次调用
auto l = [] {std::cout << "hello lambda" << std::endl;};
...
// 打印hello lambda
l();
```

$[\dots](\dots)\quad mutable_{opt}\quad throwSpace_{opt}\quad \rightarrow retType_{opt}\quad \{\dots\}$
+ Option<br>
If one of options occurs, the parentheses for the parameters are mandatory.

# 右值引用(rvalue references)
Rvalue references help solve the problem of unnecessary copying and enable perfect forwarding. When the right-hand side of an assignment is an rvalue, then the left-hand side object can **steal** resources from the right-hand side object rather than performing a separate allocation, thus enabling *move semantics*.<br>
只能发生于指针操作<br>
Lvalue: 可以出现于operator=左侧者，左值就是变量<br>
Rvalue: 只能出现于operator=右侧者，**临时对象是右值**，右值没有名称<br>
```
// 通过int试验
int a = 9;
int b = 8;

a = b; // ok, a is lvalue
b = a; // ok, b is lvalue
a = a + b; // ok, a is lvalue

// 下面一行报错，[Error] lvalue required as left operand of assignment
// a + b is rvalus
// a + b = 89;
```
```
// 通过string试验
string s1("Hello ");
string s2("World");
s1 + s2 = s2; // 竟然编译通过
cout << "s1: " << s1 << endl;
cout << "s2: " << s2 << endl;
string() = "World"; // 竟然可以对临时对象(temp obj)赋值
```
```
// 通过复数试验
complex<int> c1(3, 1), c2(1, 0);
c1 + c2 = complex<int>(5, 9); // c1 + c2可以当作lvalue吗？--YES
cout << "c1: " << c1 << endl;
cout << "c2: " << c2 << endl;
complex<int>() = complex<int>(5, 6); // 竟然可以对临时对象赋值
```

+ Rvalue: 只能出现于operator=右侧
函数返回的东西为右值，不可以对右值取地址
```
int foo() {return 5;}

int x = foo(); // ok
int* p = &foo(); // Error, 对Rvalue取其reference，不可以，没有所谓右值引用(Rvalue reference)，再C++0x之前
foo() = 7; // Error
```
当右值(rvalue)出现于operator=(copy assignment)的右侧，我们认为对其资源进行偷取/搬移(move)而非拷贝(copy)是可以的，合理的。<br>
那么：
+  必须有语法让我们在调用端告诉编译器"这是个右值(rvalue)"
+  必须有语法让我们在被调用端写出一个专门处理右值(rvalue)的所谓move assignment函数
右值引用和搬移语义(rvalue reference and move semantics)
```
class MyString {
private:
    char* _data;
    ...
public:
    // copy ctor
    MyString(const MyString& str) : initialization list {...}
    // copy assignment
    MyString& operator=(const MyString& str) {
        ...
        return *this;
    }
    // move ctor
    MyString(MyString&& str) noexcept : initialization list {...}
    // move assignment
    MyString& operator=(MyString&& str) noexcept {
        ...
        return *this;
    }
};
```
noexcept: You need to inform C++ that your move constructor and destructor does not throw. Then the move constructor will be called when the vector grows.<br>
临时对象一定被当作rvalue

```
template <typename M>
void test_moveable(M c, long& value) {
    char buf[10];

    typedef typename iterator_traits<typename M::iterator>::value_type Vtype;
    clock_t timeStart = clock();
    for (long i = 0; i < value; ++i) {
        snprintf(buf, 10, "%d", rand()); // 随机数转换为字符串
        auto ite = c.end(); // 定位于尾端
        c.insert(ite, Vtype(buf)); // 创建临时对象，插入容器
    }
    cout << "milli-seconds: " << (clock()-timeStart) << endl;
    cout << "size() = " << c.size() << endl;
    output_static_data(*(c.begin()));

    M c1(c);
    M c2(std::move(c1)); // 必须保证后续不再使用c1，移动左值
    c1.swap(c2);
}
```
```
// copy，非右值引用，执行这行
insert(..., &x);
// move，如果是右值引用，执行这行
insert(..., &&x);
```
编译器遇到临时对象(temp object)，一定把他当作右值引用，调用临时对象的构造函数(拷贝构造函数)<br>
move函数就是为了进行变量移动
1.发起动作，允许被偷(移动)，创建临时对象或者使用move函数
2.接收端拥有新的语法，能够进行偷的动作
3.被偷对象拥有可以偷的版本(浅拷贝)

```
// G2.9
iterator insert(iterator position, const T& x) {
    size_type n = position - begin();
    if (finish != end_of_storage && position == end()) {
        construct(finish, x);
        ++finish;
    } else {
        insert_aux(position, x);
    }
    return begin() + n;
}

// G4.9
iterator(const_iterator __position, const value_type& __x);

iterator(const_iterator __position, value_type&& __x) {
    return emplace(__position, std::move(__x));
}
```

# unperfect forwarding
```
void process(int& i) {
    cout << "process(int&) << i << endl;
}
void process(int&& i) {
    cout << "process(int&&):" << i << endl;
}
void forward(int&& i) {
    cout << "forward(int&&):" << i << ", ";
    process(i);
}
int a = 0;
// 被视为lvalue处理
process(a); // process(int&):0
// 临时对象被视为rvalue处理
process(1); // process(int&&):1
// 强制将a由lvalue改为rvalue
process(move(a)); // process(int&&):0

// rvalue经由forward传给另一个函数却变为lvalue
// 原因是传递过程中它变成一个named object
forward(2); // forward(int&&):2, process(int&):2

// rvalue经由forward传递给另一个函数却变成lvalue
forward(move(a)); // forward(int&&):0, process(int&):0

// 下面报错
forward(a); // Error can't bind 'int' lvalue to 'int&&'

const int& b = 1;
// 下面报错
process(b); // Error no matching function for call to 'process(const int&)''

// 下面报错
process(b); // Error no maching function for call to 'process(std::remove_reference<const int&>::type)'

// 下面报错
int& x(5); // Error invalid initiallization of non-const reference of type 'int&' from an rvalue of type 'int'

// 下面报错
process(move(x)); // Error x was not decalared in this scope
```

# perfect forwarding

```
template <typename _Tp>
constexpr _Tp&& forward(typename std::remove_reference<_Tp>::type& __t) noexcept {return static_cast<_Tp&&>(__t);}

template <typename _Tp>
constexpr _Tp&& forward(typename std::remove_reference<_Tp>::type&& __t) noexcept {static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument substituting _Tp is an lvalue reference type");
return static_cast<_Tp&&>(__t);
}

template <typename T1, typename T2>
void functionA(T1&& t1, T2&& t2) {
    functionB(std::forward<T1>(t1), std::forward<T2>(t2));
}
```
